#!/usr/bin/env wish9.0
package require cmdline
package require fileutil
package require json
package require unix_sockets
package require zstatus::config @PROJECT_VERSION@

set messagedict [dict create\
	reload zstatus::reload_config\
	theme zstatus::set_theme\
	menu zstatus::startmenu ]

proc char_count {str chr} {
    expr {[string length $str]-[string length [string map "$chr {}" $str]]}
};

proc every {ms cmd} {
	after $ms [namespace code [info level 0]]
	eval $cmd
}

namespace eval zstatus {
	variable theme	none
	variable modlist {}
	variable menudef {}
	variable rootmenu ""
	variable launchertitle $::unicode(menu)
}

proc zstatus::load_module {module} {
	variable modlist
	set index [lsearch $modlist $module]
	if {$index < 0} {
		lappend modlist $module
		package require zstatus::$module @PROJECT_VERSION@
	}
}

proc zstatus::map_window {window} {
	set rwidth [winfo vrootwidth .]
	set rheight [winfo vrootheight .]
	set width [winfo width $window]
	set height [winfo height $window]
	set xpos [winfo rootx $window]
	set ypos [winfo rooty $window]

	set right [expr $xpos + $width]
	if {$right >= $rwidth} {
		set xpos [expr $rwidth - $width - 2]
	}
	if {$xpos < 1} { set xpos 1 }

	set bottom [expr $ypos + $height]
	if {$bottom >= $rheight} {
		set ypos [expr $rheight - $height - 2]
	}

	set hbar [winfo height .]
	if [winfo rooty .] {
		set limit [expr $rheight - $hbar - $height - 1]
		if {$ypos > $limit} { set ypos $limit }
	} else {
		if {$ypos <= $hbar} { set ypos [expr $hbar + 1] }
	}

	wm geometry $window ${width}x${height}+$xpos+$ypos
}

proc zstatus::update {} {
	variable proclist
	foreach p $proclist { $p }
}

proc zstatus::set_datetime {} {
	variable datetime
	variable datetime_format
	variable locale

	set datetime [clock format [clock seconds] \
		-locale $locale -format $datetime_format]
}

proc zstatus::set_theme {newtheme} {
	variable theme

	set theme $newtheme
	if {$theme != "light" && $theme != "dark"} {
		set theme "light"
	}

	variable fgmenu
	variable bgmenu
	variable fgmenu2
	variable bgmenu2
	set fgmenu [dict get $::color fg $theme]
	set bgmenu [dict get $::color bg $theme]
	set fgmenu2 [dict get $::color fg2 $theme]
	set bgmenu2 [dict get $::color bg2 $theme]

	variable bar
	$bar configure -background [dict get $::color bg $theme]
	set count 0
	variable widgetlist
	foreach item $widgetlist {
		switch [dict get $::widgetdict $item type] {
		transient { }
		separator {
			incr count
			$bar.$item$count configure\
				-background [dict get $::widgetdict separator bg $theme]
		}
		menubutton {
			$bar.$item configure\
				-bg [dict get $::widgetdict $item bg $theme]\
				-fg [dict get $::widgetdict $item fg $theme]\
				-activebackground $bgmenu2\
				-activeforeground $fgmenu2
		}
		frame {
			$bar.$item configure\
				-bg [dict get $::widgetdict $item bg $theme]
		}
		default {
			$bar.$item configure\
				-bg [dict get $::widgetdict $item bg $theme]\
				-fg [dict get $::widgetdict $item fg $theme]
		}}
	}

	variable modlist
	foreach module $modlist {
		if [dict exists $::moduledict $module themefunc] {
			[dict get $::moduledict $module themefunc] $theme
		}
	}
}

proc zstatus::startmenu {value} {
	switch $value {
	launchers {
		variable menudef
		if [dict exist $menudef menulist] {
			launcher_menu
		}
	}
	layouts {
		variable modlist
		set index [lsearch $modlist zwm]
		if {$index >= 0} {
			zstatus::zwm::layout_menu
		}
	}
	windows {
		variable modlist
		set index [lsearch $modlist zwm]
		if {$index >= 0} {
			zstatus::zwm::client_menu
		}
	}}
}

proc zstatus::load_menudef { } {
	set menufile [dict get $::config menudef]
	if ![file exists $menufile] {
		return
	}
	variable menudef
	set content [fileutil::cat $menufile]
	if [catch {dict set menudef {*}[json::json2dict $content]}] {
		puts "Invalid JSON format in \[$menufile\]"
	}
}

proc zstatus::launcher_menu {} {
	set menu [gen_launcher_menu ""]
	if [string length $menu] {
		$menu post {*}[winfo pointerxy .]
	}
}

proc zstatus::gen_launcher_menu { prefix } {
	variable fgmenu
	variable bgmenu
	variable fgmenu2
	variable bgmenu2

	set basemenu ""
	variable menudef
	set menulist [dict get $menudef menulist]
	foreach menudict $menulist {
		set leaf [dict get $menudict path]
		set path "${prefix}.${leaf}"
		if [winfo exists $path] {
			$path delete 0 end
		} else {
			menu $path
		}
		$path configure -font large\
			-relief flat -activerelief solid\
			-foreground $fgmenu -background $bgmenu\
			-activebackground $bgmenu2 -activeforeground $fgmenu2\
			-disabledforeground $fgmenu

		if {![string length $prefix] && $leaf == "launchers"} {
			set basemenu $path
			set label [dict get $menudict label]
			$path add command -label $label\
				-state disabled\
				-background $bgmenu2
		}

		set itemlist [dict get $menudict entries]
		foreach itemdict $itemlist {
			set type ""
			set label [dict get $itemdict label]
			if [dict exists $itemdict cascade] {
				set type cascade
				set cascade "${prefix}.[dict get $itemdict cascade]"
				set leaf [lindex [split $cascade .] end]
				if {$leaf == "x11clients"} {
					variable modlist
					set index [lsearch $modlist zwm]
					if {$index < 0} { continue }
					regsub "\.${leaf}$" $cascade {} prfx
					zstatus::zwm::gen_client_menu $prfx
				} elseif {$leaf == "layouts"} {
					variable modlist
					set index [lsearch $modlist zwm]
					if {$index < 0} { continue }
					regsub "\.${leaf}$" $cascade {} prfx
					zstatus::zwm::gen_layout_menu $prfx
				}
			}
			if [dict exists $itemdict command] {
				set type command
				set command "[dict get $itemdict command] &"
			}
			if {$type == "command"} {
				$path add $type -label " $label" -command $command
			} elseif {$type == "cascade"} {
				$path add $type -label " $label" -menu $cascade
			}
		}
	}
	return $basemenu
}

proc zstatus::read_message {channel} {
	set message [chan read $channel 4096]
	chan close $channel

	if [catch {dict set keyval {*}[json::json2dict $message]}] {
		return
	}
	set key [lindex $keyval 0]
	if [dict exists $::messagedict $key] {
		[dict get $::messagedict $key] [lindex $keyval 1]
	}
}

proc zstatus::server_accept {channel} {
	chan configure $channel -buffering none -blocking 0
	chan event $channel readable [list zstatus::read_message $channel]
}

proc zstatus::add_widgets {side widgets} {
	variable bar
	variable proclist
	variable sepcount
	variable widgetlist
	variable rootmenu

	# Sanitize the provided list
	regsub -all {\"} $widgets {} widgets
	regsub -all {,} $widgets { } widgets
	regsub -all {[ ]+} $widgets { } widgets

	set last $bar
	foreach item [split $widgets] {
		if {$item == "sep"} {
			set item "separator"
		}
		if ![dict exists $::widgetdict $item] { continue }

		switch [dict get $::widgetdict $item type] {
		text {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			set expand [dict get $::widgetdict $item expand]
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side -expand $expand
			set last $item
		}
		string {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			pack [label $bar.$item\
				-font [dict get $::widgetdict $item font]\
				-textvar [dict get $::widgetdict $item source]\
				-padx 5] -side $side
			if [dict exists $::widgetdict $item module] {
				zstatus::${module}::setup $bar $item
			}
			set last $item
		}
		menubutton {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			set prefix $bar.$item
			set path $prefix.[dict get $::widgetdict $item path]
			pack [menubutton $prefix\
				-font [dict get $::widgetdict $item font]\
				-textvar [dict get $::widgetdict $item source]\
				-menu $path\
				-padx 5] -side $side

			menu $path -postcommand\
				"[dict get $::widgetdict $item post] $prefix"

			if [dict exists $::widgetdict $item module] {
				zstatus::${module}::setup $bar $item
			}
			set last $item
		}
		frame {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side
			set last $item
		}
		separator {
			incr sepcount
			pack [frame $bar.$item$sepcount -width 1]\
				-fill y -side $side
			set last $item$sepcount
		}
		transient {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			zstatus::${module}::setup $bar $last $side
		}}

		if [dict exists $::widgetdict $item proc] {
			lappend proclist [dict get $::widgetdict $item proc]
		}
		lappend widgetlist $item
	}
}

proc zstatus::make_font {} {
	set fontsize [dict get $::config fontsize]
	set fontname [dict get $::config fontname]
	set font_pua [dict get $::config font_pua]

	regsub -all {\"} $fontname {} fontname
	regsub -all {\-} $fontname {} fontname
	regsub -all { } $fontname {} fontname

	set defined_fonts [font names]
	set fonts { small normal italic italic2 bold bold2\
				large large2 pua1 pua2 mono emoji }

	foreach f $fonts {
		set index [lsearch $defined_fonts $f]
		if {$index >= 0} {
			font delete $f
		}
	}

	font create small -family $fontname -size [expr $fontsize - 1]
	font create normal -family $fontname -size $fontsize
	font create italic -family $fontname -size $fontsize -slant italic
	font create italic2 -family $fontname -size [expr $fontsize + 1]\
		 -slant italic
	font create bold -family $fontname -size $fontsize -weight bold
	font create bold2 -family $fontname -size [expr $fontsize + 1]\
		 -weight bold
	font create large -family $fontname -size [expr $fontsize + 1]
	font create large2 -family $fontname -size [expr $fontsize + 2]
	font create pua1 -family $font_pua -size [expr $fontsize]
	font create pua2 -family $font_pua -size [expr $fontsize + 1]
	font create mono -family "$fontname Mono" -size $fontsize

	if {[dict exists $::config emojifont]} {
		set emojifont [dict get $::config emojifont]
		regsub -all {\"} $emojifont {} emojifont
		regsub -all {\-} $emojifont {} emojifont
		regsub -all { } $emojifont {} emojifont
		font create emoji -family $emojifont -size $fontsize
	}

	set ascent [font metrics large2 -ascent]
	set descent [font metrics large2 -descent]
	return [expr $ascent + $descent + 2]
}

proc zstatus::reload_config {dummy} {
	variable bar
	destroy $bar
	config::read $::params(config)
	setup
}

proc zstatus::setup {} {
	variable bar
	variable theme
	variable proclist
	variable widgetlist
	variable datetime_format
	variable locale
	variable osversion
	variable sepcount

	set bar [frame .zstatus]
	pack $bar -fill both -expand 1

	set wheight [make_font]
	if {[dict get $::config position] == "bottom"} {
		set position "+0-0"
	} else {
		set position "+0+0"
	}
	if ![dict exists $::config geometry] {
		dict set ::config geometry "[winfo vrootwidth .]x${wheight}${position}"
	}
	wm geometry . [dict get $::config geometry]

	set sepcount 0
	set proclist {}
	set widgetlist {}
	add_widgets left [dict get $::config leftside]
	add_widgets right [dict get $::config rightside]

	set datetime_format [dict get $::widgetdict datetime format]
	set locale [dict get $::config locale]
	set osversion [exec uname -rs]
	set_theme $theme
	load_menudef
}

# Treat command line options
set options {
	{config.arg "default" "user configuration file"}
	{theme.arg "" "default theme"}
}
set usage ": zstatus.tk -config <configfile> -theme <theme> \n"

try {
	array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
	puts $msg
	exit 1
}

# Setup tk app
tk appname "@PROJECT_NAME@"
wm title . "@PROJECT_NAME@ @PROJECT_VERSION@"
wm attributes . -type dock

zstatus::config::read $params(config)
if [string length $::params(theme)] {
	set zstatus::theme $::params(theme)
} elseif [dict exists $::config theme] {
	set zstatus::theme [dict get $::config theme]
} elseif [info exists ::env(THEME_STATE_FILE)] {
	set themefile $env(THEME_STATE_FILE)
	if [file exists $themefile] {
		set zstatus::theme [lindex [split [fileutil::cat $themefile] "\n"] 0]
	}
}

zstatus::setup
every [dict get $::config delay] zstatus::update

set barsocket "[dict get $::config cache_prefix]/zstatus/socket"
unix_sockets::listen $barsocket zstatus::server_accept
vwait forever
