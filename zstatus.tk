#!/usr/bin/env wish9.0
package require cmdline
package require fileutil
package require json
package require unix_sockets
package require zstatus::config
package require zstatus::remixicon

set messagedict [dict create\
	reload_config {
		action reload_config arg 0
	} set_theme {
		action set_theme arg 1
	} launcher_menu {
		action launcher_menu arg 0
	}]

proc char_count {str chr} {
    expr {[string length $str]-[string length [string map "$chr {}" $str]]}
};

proc every {ms cmd} {
	after $ms [namespace code [info level 0]]
	eval $cmd
}

namespace eval zstatus {
	variable theme	none
	variable modlist {}
	variable menudef {}
	variable rootmenu ""
}

proc zstatus::load_module {module} {
	variable modlist
	set index [lsearch $modlist $module]
	if {$index < 0} {
		lappend modlist $module
		package require zstatus::$module
	}
}

proc zstatus::map_window {window} {
	set rwidth [winfo vrootwidth .]
	set rheight [winfo vrootheight .]
	set width [winfo width $window]
	set height [winfo height $window]
	set xpos [winfo rootx $window]
	set ypos [winfo rooty $window]

	set right [expr $xpos + $width]
	if {$right >= $rwidth} {
		set xpos [expr $rwidth - $width - 2]
	}
	if {$xpos < 1} { set xpos 1 }

	set bottom [expr $ypos + $height]
	if {$bottom >= $rheight} {
		set ypos [expr $rheight - $height - 2]
	}

	set hbar [winfo height .]
	if [winfo rooty .] {
		set limit [expr $rheight - $hbar - $height - 1]
		if {$ypos > $limit} { set ypos $limit }
	} else {
		if {$ypos <= $hbar} { set ypos [expr $hbar + 1] }
	}

	wm geometry $window ${width}x${height}+$xpos+$ypos
}

proc zstatus::update {} {
	variable proclist
	foreach p $proclist { $p }
}

proc zstatus::set_datetime {} {
	variable datetime
	variable datetime_format
	variable locale

	set datetime [clock format [clock seconds] \
		-locale $locale -format $datetime_format]
}

proc zstatus::set_theme {newtheme} {
	variable theme

	set theme $newtheme
	if {$theme != "light" && $theme != "dark"} {
		set theme "light"
	}

	variable fgmenu
	variable bgmenu
	variable fgmenu2
	variable bgmenu2
	set fgmenu [dict get $::color fg $theme]
	set bgmenu [dict get $::color bg $theme]
	set fgmenu2 [dict get $::color fg2 $theme]
	set bgmenu2 [dict get $::color bg2 $theme]

	variable bar
	variable widgetlist
	set count 0
	$bar configure -background [dict get $::color bg $theme]
	foreach item $widgetlist {
		switch [dict get $::widgetdict $item type] {
		transient {
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}
		separator {
			incr count
			$bar.$item$count configure\
				-background [dict get $::widgetdict separator bg $theme]
		}
		widget {
			$bar.$item configure\
				-bg [dict get $::widgetdict $item bg $theme]
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}
		default {
			$bar.$item configure\
				-bg [dict get $::widgetdict $item bg $theme]\
				-fg [dict get $::widgetdict $item fg $theme]
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}}
	}
}

proc zstatus::setup_menu {} {
	set menufile [dict get $::config menudef]
	if ![file exists $menufile] {
		return
	}
	variable menudef
	set content [fileutil::cat $menufile]
	if [catch {dict set menudef {*}[json::json2dict $content]}] {
		puts "Invalid JSON format in \[$menufile\]"
		return
	}

	variable rootmenu
	if [string length $rootmenu] {
		destroy $rootmenu
		set rootmenu ""
	}

	variable fgmenu
	variable bgmenu
	variable fgmenu2
	variable bgmenu2

	set menulist [dict get $menudef menulist]
	foreach menudict $menulist {
		set path [dict get $menudict path]
		if {[char_count $path .] == 1} {
			set rootmenu $path
		}

		set label [dict get $menudict label]
		set menu [menu $path -title $label -font large\
			-relief flat -activerelief solid\
			-foreground $fgmenu -background $bgmenu\
			-activebackground $bgmenu2 -activeforeground $fgmenu2\
			-disabledforeground $fgmenu]

		$menu add command -label $label -state disabled\
			 -background $bgmenu2

		set itemlist [dict get $menudict entries]
		foreach itemdict $itemlist {
			set type ""
			set icon ""
			set label [dict get $itemdict label]
			if [dict exists $itemdict cascade] {
				set type cascade
				set cascade [dict get $itemdict cascade]
			}
			if [dict exists $itemdict command] {
				set type command
				set command "[dict get $itemdict command] &"
			}
			if [dict exists $itemdict icon] {
				#set icon "-icon [dict get $itemdict icon]"
			}
			if {$type == "command"} {
				$menu add $type -label $label -command $command
			} elseif {$type == "cascade"} {
				$menu add $type -label $label -menu $cascade
			}
		}
	}
}

proc zstatus::launcher_menu {} {
	variable rootmenu
	if [string length $rootmenu] {
		$rootmenu post {*}[winfo pointerxy .]
	}
}

proc zstatus::read_message {channel} {
	set message [chan read $channel 4096]
	chan close $channel

	set message [string trimright $message "\n"]
	set equal [string first "=" $message]
	if {$equal == -1} {
		set key $message
		set value ""
	} elseif {$equal > 0} {
		set key [string range $message 0 $equal-1]
		set value [string range $message $equal+1 end]
	} else {
		return
	}
	if { ![dict exists $::messagedict $key] } { return }
	set action [dict get $::messagedict $key action]
	set arg [dict get $::messagedict $key arg]
	if {$arg == 1} {
		$action $value
	} else {
		$action
	}
}

proc zstatus::server_accept {channel} {
	chan configure $channel -buffering none -blocking 0
	chan event $channel readable [list zstatus::read_message $channel]
}

proc zstatus::add_widgets {side widgets} {
	variable bar
	variable proclist
	variable sepcount
	variable widgetlist

	# Sanitize the provided list
	regsub -all {\"} $widgets {} widgets
	regsub -all {,} $widgets { } widgets
	regsub -all {[ ]+} $widgets { } widgets

	set last $bar
	foreach item [split $widgets] {
		if {$item == "sep"} {
			set item "separator"
		}
		if ![dict exists $::widgetdict $item] { continue }

		switch [dict get $::widgetdict $item type] {
		text {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			set expand [dict get $::widgetdict $item expand]
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side -expand $expand
			set last $item
		}
		string {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			pack [label $bar.$item\
				-font [dict get $::widgetdict $item font]\
				-textvar [dict get $::widgetdict $item source]\
				-padx 5] -side $side
			if [dict exists $::widgetdict $item module] {
				zstatus::${module}::setup $bar $item
			}
			set last $item
		}
		widget {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side
			set last $item
		}
		separator {
			incr sepcount
			pack [frame $bar.$item$sepcount -width 1]\
				-fill y -side $side
			set last $item$sepcount
		}
		transient {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			zstatus::${module}::setup $bar $last $side
		}}

		if [dict exists $::widgetdict $item proc] {
			lappend proclist [dict get $::widgetdict $item proc]
		}
		lappend widgetlist $item
	}
}

proc zstatus::make_font {} {
	set fontsize [dict get $::config fontsize]
	set fontname [dict get $::config fontname]

	regsub -all {\"} $fontname {} fontname
	regsub -all {\-} $fontname {} fontname
	regsub -all { } $fontname {} fontname

	set defined_fonts [font names]
	set fonts { small normal italic italic2 bold bold2\
				large large2 remix1 remix2 mono emoji }

	foreach f $fonts {
		set index [lsearch $defined_fonts $f]
		if {$index >= 0} {
			font delete $f
		}
	}

	font create small -family $fontname -size [expr $fontsize - 1]
	font create normal -family $fontname -size $fontsize
	font create italic -family $fontname -size $fontsize -slant italic
	font create italic2 -family $fontname -size [expr $fontsize + 1]\
		 -slant italic
	font create bold -family $fontname -size $fontsize -weight bold
	font create bold2 -family $fontname -size [expr $fontsize + 1]\
		 -weight bold
	font create large -family $fontname -size [expr $fontsize + 1]
	font create large2 -family $fontname -size [expr $fontsize + 2]
	font create remix1 -family remixicon -size [expr $fontsize]
	font create remix2 -family remixicon -size [expr $fontsize + 1]
	font create mono -family "$fontname Mono" -size $fontsize

	if {[dict exists $::config emojifont]} {
		set emojifont [dict get $::config emojifont]
		regsub -all {\"} $emojifont {} emojifont
		regsub -all {\-} $emojifont {} emojifont
		regsub -all { } $emojifont {} emojifont
		font create emoji -family $emojifont -size $fontsize
	}

	set ascent [font metrics large2 -ascent]
	set descent [font metrics large2 -descent]
	return [expr $ascent + $descent]
}

proc zstatus::reload_config {} {
	variable bar
	destroy $bar
	config::read $::params(config)
	setup
}

proc zstatus::setup {} {
	variable bar
	variable theme
	variable proclist
	variable widgetlist
	variable datetime_format
	variable locale
	variable osversion
	variable sepcount

	set bar [frame .zstatus]
	pack $bar -fill both -expand 1

	set wheight [make_font]
	if {[dict get $::config position] == "bottom"} {
		set position "+0-0"
	} else {
		set position "+0+0"
	}
	if ![dict exists $::config geometry] {
		dict set ::config geometry "[winfo vrootwidth .]x${wheight}${position}"
	}
	wm geometry . [dict get $::config geometry]

	set sepcount 0
	set proclist {}
	set widgetlist {}
	add_widgets left [dict get $::config leftside]
	add_widgets right [dict get $::config rightside]

	set datetime_format [dict get $::widgetdict datetime format]
	set locale [dict get $::config locale]
	set osversion [exec uname -rs]
	set_theme $theme
	setup_menu
}

# Treat command line options
set options {
	{config.arg "default" "user configuration file"}
	{theme.arg "" "default theme"}
}
set usage ": zstatus.tk -config <configfile> -theme <theme> \n"

try {
	array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
	puts $msg
	exit 1
}

# Setup tk app
tk appname "@PACKAGE_NAME@"
wm title . "@PACKAGE_NAME@ @PACKAGE_VERSION@"
wm attributes . -type dock

# Unicode mapping from remixicon v4.6.0
array set unicode [zstatus::remixicon::get]
zstatus::config::read $params(config)
if [string length $::params(theme)] {
	set zstatus::theme $::params(theme)
} elseif [dict exists $::config theme] {
	set zstatus::theme [dict get $::config theme]
} elseif [info exists ::env(THEME_STATE_FILE)] {
	set themefile $env(THEME_STATE_FILE)
	if [file exists $themefile] {
		set zstatus::theme [lindex [split [fileutil::cat $themefile] "\n"] 0]
	}
}

zstatus::setup
every [dict get $::config delay] zstatus::update

set barsocket "[dict get $::config cache_prefix]/zstatus/socket"
unix_sockets::listen $barsocket zstatus::server_accept
vwait forever
