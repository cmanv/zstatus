#!/usr/bin/env wish9.0
package require cmdline
package require unix_sockets
package require zstatus::config
package require zstatus::remixicon

set widgetdict [dict create\
	datetime {type string source zstatus::datetime proc set_datetime\
		format {%d %b %H:%M} font normal light black dark LightGray}\
	desklist {type widget module desktop settheme desktop::set_desktheme\
		font normal light black dark LightGray}\
	deskmode {type string module desktop source zstatus::desktop::deskmode\
		font normal light black dark LightGray}\
	deskname {type string module desktop source zstatus::desktop::deskname\
		font normal light black dark LightGray}\
	devices {type transient module devices proc devices::update\
		settheme devices::set_theme font bold light black dark LightGray}\
	loadavg {type string module system source zstatus::system::loadavg\
		proc system::set_loadavg\
		font normal light black dark LightGray}\
	mail {type transient module mail proc mail::update\
		settheme mail::set_theme font normal light black dark LightGray}\
	memused {type string module system source zstatus::system::memused\
		proc system::set_memused settheme system::set_theme\
		font normal light black dark LightGray}\
	metar {type string module metar source zstatus::metar::report(statusbar)\
		settheme metar::set_theme delay 10\
		font remix1 light black dark LightGray}\
	mixer {type string module system source zstatus::system::mixer\
		font normal light black dark LightGray}\
	music {type transient module music proc music::update\
		settheme music::set_theme font normal light black dark LightGray}\
	netstat {type string module system source zstatus::system::interface\
		proc system::update_netstat interface em0\
		settheme system::set_theme font normal light black dark LightGray}\
	osversion {type string source zstatus::osversion\
		font normal light black dark LightGray}\
	separator {type separator light black dark gray}\
	statusbar {type bar light gray90 dark gray20}\
	wintitle {type text module desktop expand 0 maxlength 100\
		font normal light black dark LightGray}]

set messagedict [dict create set_theme {action set_theme arg 1}]

proc every {ms cmd} {
	after $ms [namespace code [info level 0]]
	eval $cmd
}

namespace eval zstatus {
	variable theme	none
	variable proclist	{}
	variable modlist	{}
}

proc zstatus::load_module {module} {
	variable modlist
	set index [lsearch $modlist $module]
	if {$index < 0} {
		lappend modlist $module
		package require zstatus::$module
	}
}

proc zstatus::map_window {window} {
	set rwidth [winfo vrootwidth .]
	set rheight [winfo vrootheight .]
	set width [winfo width $window]
	set height [winfo height $window]
	set xpos [winfo x $window]
	set ypos [winfo y $window]

	set right [expr $xpos + $width]
	if {$right >= $rwidth} {
		set xpos [expr $rwidth - $width - 2]
	}
	if {$xpos < 1} { set xpos 1 }

	set bottom [expr $ypos + $height]
	if {$bottom >= $rheight} {
		set ypos [expr $rheight - $height - 2]
	}

	set hbar [winfo height .]
	if [winfo rooty .] {
		set limit [expr $rheight - $hbar - $height - 1]
		if {$ypos > $limit} { set ypos $limit }
	} else {
		if {$ypos <= $hbar} { set ypos [expr $hbar + 1] }
	}

	wm geometry $window ${width}x${height}+$xpos+$ypos
}

proc zstatus::update {} {
	variable proclist
	foreach p $proclist { $p }
}

proc zstatus::set_datetime {} {
	variable datetime
	variable datetime_format
	variable locale

	set datetime [clock format [clock seconds] \
		-locale $locale  -format $datetime_format]
}

proc zstatus::set_theme {newtheme} {
	variable theme
	if {$theme == $newtheme} { return }
	set theme $newtheme

	variable bar
	variable widgetlist
	set bartheme [dict get $::widgetdict statusbar $theme]

	set count 0
	$bar configure -background $bartheme
	foreach item $widgetlist {
		switch [dict get $::widgetdict $item type] {
		bar {}
		transient {
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}
		separator {
			incr count
			$bar.$item$count configure\
				-background [dict get $::widgetdict $item $theme]
		}
		widget {
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}
		default {
			$bar.$item configure -bg $bartheme\
				-fg [dict get $::widgetdict $item $theme]
			if [dict exists $::widgetdict $item settheme] {
				[dict get $::widgetdict $item settheme] $theme
			}
		}}
	}
}

proc zstatus::read_message {channel} {
	if {[gets $channel line] < 0} {
		close $channel
		return
	}
	close $channel

	set line [string trimright $line]
	set equal [string first "=" $line]
	if {$equal == -1} {
		set key $line
		set value ""
	} elseif {$equal > 0} {
		set key [string range $line 0 $equal-1]
		set value [string range $line $equal+1 end]
	} else {
		return
	}

	if { ![dict exists $::messagedict $key] } { return }
	set action [dict get $::messagedict $key action]
	set arg [dict get $::messagedict $key arg]
	if {$arg == 1} {
		$action $value
	} else {
		$action
	}
}

proc zstatus::server_accept {channel} {
	chan configure $channel -buffering none -blocking 0
	chan event $channel readable [list zstatus::read_message $channel]
}

proc zstatus::add_widgets {side widgets} {
	variable bar
	variable proclist
	variable sepcount
	variable widgetlist

	# Sanitize the provided list
	regsub -all {\"} $widgets {} widgets
	regsub -all {,} $widgets { } widgets
	regsub -all {[ ]+} $widgets { } widgets

	set last $bar
	foreach item [split $widgets] {
		if {$item == "sep"} {
			set item "separator"
		}
		if ![dict exists $::widgetdict $item] { continue }
		switch [dict get $::widgetdict $item type] {
		text {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			set expand [dict get $::widgetdict $item expand]
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side -expand $expand
			set last $item
		}
		string {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			pack [label $bar.$item\
				-font [dict get $::widgetdict $item font]\
				-textvar [dict get $::widgetdict $item source]]\
				-side $side
			if [dict exists $::widgetdict $item module] {
				zstatus::${module}::setup $bar $item
			}
			set last $item
		}
		widget {
			if [dict exists $::widgetdict $item module] {
				set module [dict get $::widgetdict $item module]
				load_module $module
			}
			zstatus::${module}::setup $bar $item
			pack $bar.$item -side $side
			set last $item
		}
		separator {
			incr sepcount
			pack [frame $bar.$item$sepcount -width 1]\
				-fill y -padx 5 -side $side
			set last $item$sepcount
		}
		transient {
			if ![dict exists $::widgetdict $item module] {
				puts "No module defined for $item!"
				exit 1
			}
			set module [dict get $::widgetdict $item module]
			load_module $module
			zstatus::${module}::setup $bar $last $side
		}}

		if [dict exists $::widgetdict $item proc] {
			lappend proclist [dict get $::widgetdict $item proc]
		}
		lappend widgetlist $item
	}
}

proc zstatus::make_font {} {
	set fontsize [dict get $::config fontsize]
	set fontname [dict get $::config fontname]

	regsub -all {\"} $fontname {} fontname
	regsub -all {\-} $fontname {} fontname
	regsub -all { } $fontname {} fontname

	font create small -family $fontname -size [expr $fontsize - 1]
	font create normal -family $fontname -size $fontsize
	font create italic -family $fontname -size $fontsize -slant italic
	font create italic2 -family $fontname -size [expr $fontsize + 1] -slant italic
	font create bold -family $fontname -size $fontsize -weight bold
	font create bold2 -family $fontname -size [expr $fontsize + 1] -weight bold
	font create large -family $fontname -size [expr $fontsize + 1]
	font create large2 -family $fontname -size [expr $fontsize + 2]
	font create remix1 -family remixicon -size [expr $fontsize]
	font create remix2 -family remixicon -size [expr $fontsize + 1]

	if [dict exists $::config emojifont] {
		set emojifont [dict get $::config emojifont]
		regsub -all {\"} $emojifont {} emojifont
		regsub -all {\-} $emojifont {} emojifont
		regsub -all { } $emojifont {} emojifont
		font create emoji -family $emojifont -size $fontsize
	}

	set ascent [font metrics large2 -ascent]
	set descent [font metrics large2 -descent]
	return [expr $ascent + $descent]
}

proc zstatus::setup {} {
	variable bar
	variable widgetlist
	variable datetime_format
	variable locale
	variable osversion
	variable sepcount

	set bar [frame .zstatus]
	pack $bar -fill both -expand 1

	set wheight [make_font]
	if {[dict get $::config position] == "bottom"} {
		set position "+0-0"
	} else {
		set position "+0+0"
	}
	if ![dict exists $::config geometry] {
		dict set ::config geometry "[winfo vrootwidth .]x${wheight}${position}"
	}
	wm geometry . [dict get $::config geometry]

	set sepcount 0
	set widgetlist {}
	add_widgets left [dict get $::config leftside]
	add_widgets right [dict get $::config rightside]

	set datetime_format [dict get $::widgetdict datetime format]
	set locale [dict get $::config lang]
	set osversion [exec uname -rs]

	set theme ""
	if [dict exists $::config theme] {
		set theme [dict get $::config theme]
	} elseif [string length $::params(theme)] {
		set theme $::params(theme)
	}
	if {$theme != "light" && $theme != "dark"} {
		set theme "light"
	}
	set_theme $theme
}

# Treat command line options
set options {
	{config.arg "default" "user configuration file"}
        {theme.arg  ""  "default theme"}
}
set usage ": zstatus.tk -config <configfile> -theme <theme> \n"

try {
	array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
	puts $msg
	exit 1
}

# Setup tk app
tk appname "@PACKAGE_NAME@"
wm title . "@PACKAGE_NAME@ @PACKAGE_VERSION@"
wm attributes . -topmost 1 -type dock

# Unicode mapping from remixicon v4.6.0
array set unicode [zstatus::remixicon::get]
# Read config
set config [zstatus::config::read $params(config)]

zstatus::setup
every [dict get $config delay] zstatus::update

set barsocket "[dict get $config cache_prefix]/zstatus/socket"
unix_sockets::listen $barsocket zstatus::server_accept
vwait forever
